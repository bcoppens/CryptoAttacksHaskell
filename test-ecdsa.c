#include <openssl/bn.h>
#include <openssl/ec.h>
#include <openssl/ecdsa.h>
#include <openssl/err.h>
#include <openssl/objects.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <assert.h>
#include <execinfo.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static __inline__ unsigned long long rdtsc(void)
{
  unsigned hi, lo;
  __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
  return ( (unsigned long long)lo)|( ((unsigned long long)hi)<<32 );
}

static const char* test_string = "This is a message to be signed";

#define CALIBRATION

#ifdef CALIBRATION

BIGNUM* group_order;
BIGNUM* generated_k;

/*
    We have a fake random generator to see which random k is generated by the EC-DSA code so we can correlate that with our timings
    What we do is the following:
    * Save the random state, and set a custom random number generator.
    * This random number generator looks at whether or not it was called from where the randomness for k is generated. If so, it logs the random k.
    * We reset the random state & original random number generator.
    * We rerun the signing. It will use the same random numbers as before, but we will not have interfered in the execution time at all
*/

// Checks if this is being used for generating a random k. _VERY_ implementation specific! Ahem :(

//   415256:       e8 95 f4 fe ff          callq  4046f0 <BN_rand_range>
// -> this one  41525b:       85 c0                   test   %eax,%eax
int __attribute__ ((noinline)) is_generating_random_k() {
    long* stack;
    __asm__ __volatile__("movq %%rsp, %0" : "=r"(stack));
    return stack[22] == 0x000000000041528b; // #9 in ecdsa_sign_setup
}

// More fugly hacky code starting. Sorry...
RAND_METHOD old_random;
RAND_METHOD* our_random;

static int is_logging = 0;

static void (*orig_seed)(const void *buf, int num) = 0;
static int seed_cnt = 0;

typedef struct {
    int ret;
    unsigned char* data;
} bytes_log_entry;

#define MAX_LOG 20
static bytes_log_entry bytes_log[MAX_LOG];
static int (*orig_bytes)(unsigned char *buf, int num) = 0;
static int bytes_cnt = 0;


static int logging_bytes(unsigned char *buf, int num) {
    int ret;

    if (is_logging) {
        bytes_log[bytes_cnt].data = malloc(sizeof(unsigned char) * num);
        assert(orig_bytes != logging_bytes);
        bytes_log[bytes_cnt].ret = ret = orig_bytes(bytes_log[bytes_cnt].data, num);
        memcpy(buf, bytes_log[bytes_cnt].data, num);
        bytes_cnt++;
    } else {
        // Replay the log
        bytes_cnt--;
        memcpy(buf, bytes_log[bytes_cnt].data, num);
        free(bytes_log[bytes_cnt].data);

        if (bytes_cnt == 0) {
            our_random->bytes = orig_bytes;
        }
        ret = bytes_log[bytes_cnt].ret;
    }
    return ret;
}

void start_logging() {
    assert(bytes_cnt == 0);
    is_logging = 1;
    orig_bytes = our_random->bytes;
    our_random->bytes = logging_bytes;
}

void replay_logging_once() {
    is_logging = 0;
    if (bytes_cnt == 0) {
        our_random->bytes = orig_bytes;
    }
}

// Implement a fake random number generator, logging the (last) random number r generated for ECDSA.
// There can be more than 1 r being generated if the algorithm has to be rerun internally.
int next_fake_random(unsigned char *buf, int bytes) {
    if (is_generating_random_k()) {
        // This randomness is for k, generate it ourselves and store it!
        start_logging();
        BN_rand_range(generated_k, group_order);
        replay_logging_once();
    }

    return old_random.bytes(buf, bytes);
}

// Set our fake random generator. We set up some additional stuff
void set_fake_random(EC_KEY* key, BN_CTX* ctx) {
    const EC_GROUP* group;
    int i;
    /* backup the old rand method */
    our_random = RAND_get_rand_method(); // DIRTY HACK, but otherwise when calling RAND_set_rand_method we destruct the old one, don't want that...

    if (!our_random)
        exit(1);

    old_random = *our_random;
    /* Set a custom random generation function */
    //fake_random.bytes = next_fake_random;

    // Set up some stuff we'll use later on
    group_order = BN_new();
    generated_k = BN_new();
    group = EC_KEY_get0_group(key);

    if (!group_order || !generated_k || ! group) {
        exit(1);
    }


    if (!EC_GROUP_get_order(group, group_order, ctx)) {
        exit(1);
    }

    our_random->bytes = next_fake_random;

#if 0
    for (i = 0; i<10; i++) {
        FILE* theoutputfile = fdopen(1, "w");
        // This randomness is for k, generate it ourselves and store it!
        if (i % 2 == 0) {
            start_logging();
            BN_rand_range(generated_k, group_order);
            replay_logging_once();
        } else {
            BN_rand_range(generated_k, group_order);
        }
        BN_print_fp(theoutputfile, generated_k);
        fprintf(theoutputfile, "\n");
    }
    exit(0);
#endif
}

#else /* CALIBRATION */

// In the real executions, we of course don't log randomness!
void set_fake_random(EC_KEY* key, BN_CTX* ctx) {}

#endif


/*
    NID_sect163k1 is the NIST Binary-Curve K-163
    NID_sect163r2 is the NIST Binary-Curve B-163
*/
int main(int argc, char** argv) {
    int ret;
    ECDSA_SIG* sig;
    EC_KEY* eckey = EC_KEY_new();
    long long before, after;
    BN_CTX* ctx = NULL;

    char digest[20];
    int i;

    FILE* theoutputfile = fdopen(1, "w");

    // Digest the string to sign with SHA-1
    SHA1(test_string, strlen(test_string), digest);

    if ((ctx=BN_CTX_new()) == NULL) goto err;

    eckey = EC_KEY_new_by_curve_name(NID_sect163k1);
    if (eckey == NULL)
        goto err;

    // Generate a public/private key pair
    if (!EC_KEY_generate_key(eckey)) goto err;

    // Potentially set up a fake random generator
    set_fake_random(eckey, ctx);

    for (i = 0; i < 100; i++) {
        char* bn_dec;
        // Compute a ECDSA signature of a SHA-1 hash value using ECDSA_do_sign, time how long it takes
        before = rdtsc();
        sig = ECDSA_do_sign(digest, 20, eckey);
        after = rdtsc();

        if (sig == NULL) {
            goto err;
        }

        // We could verify the signature if we wanted (result should be _1_ for a correct result)
        // ret = ECDSA_do_verify(digest, 20, sig, eckey);
        bn_dec = BN_bn2dec(sig->r);
        fprintf(theoutputfile, "%s,", bn_dec);
        free(bn_dec);

        bn_dec = BN_bn2dec(sig->s);
        fprintf(theoutputfile, "%s,", bn_dec);
        free(bn_dec);

        bn_dec = BN_bn2dec(sig->s);
        fprintf(theoutputfile, "%s,", bn_dec);
        free(bn_dec);

        bn_dec = BN_bn2dec(generated_k);
        fprintf(theoutputfile, "%s,", bn_dec);
        free(bn_dec);

        fprintf(theoutputfile, "%lld\n", after - before);
    }


    // We're done
err:
    ERR_print_errors_fp(stderr);

    if (eckey) EC_KEY_free(eckey);

    return 0;
}
